-define(PMAP_H,
   io:format("--- pmap description ---~n",[]),
   io:format("takes a function and a list to be split into chunks. ~n",[]),
   io:format("it spawns a process for each element in the list ",[]),
   io:format("of chunks. ~neach mapper process applies a function ",[]),
   io:format("to its chunk and collects the results (non-ordered).~n",[]),
   io:format("you may also split the list by either choosing its chunks' ",[]),
   io:format("length or by using the parameter '{processes, X}'.~n",[]),
   io:format("where X is the number of processes. the list will be ",[]),
   io:format("split into X chunks of (mostly) the same length. ~n~n",[]),
   io:format("usage example 1:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">pmap:start(fun(Chunk)-> [X*X||X<-Chunk] end,L).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[9,4,1,36,25,16,81,64,49,100]~n",[]),
   io:format("NB: the output list may be oredered differently~n",[]),

   io:format("usage example 2:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">pmap:start(fun(Chunk)-> [X*X||X<-Chunk] end, L, 2).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above~n",[]),

   io:format("usage example 3:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">pmap:start(fun(Chunk)-> [X*X||X<-Chunk] end, L, ",[]),
   io:format("{processes, 4}).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above~n",[])

).

-define(PREDUCE_H,
   io:format("--- preduce description ---~n",[]),
   io:format("takes a function, an accumulator, a list to be ",[]),
   io:format("split into chunks. ~n",[]),
   io:format("optionally, it may take an user-defined Combiner function ",[]),
   io:format("to join all results together in a single output and/or a ",[]),
   io:format("further 'Split' parameter. ~n",[]),
   io:format("the 'Split' parameter may be either a number, which will ",[]),
   io:format("set the length of each chunk, or may be of the form ",[]),
   io:format("'{procesess, X}', which will split the list into X chunks ",[]),
   io:format("of (mostly) the same length.~n",[]),
   io:format("each chunk is reduced and its output is processed by a ",[]),
   io:format("logical tree of combiners running in parallel, combining ",[]),
   io:format("all results to give a final output.~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">preduce:start(fun(A,B) -> A+B  end, 0, L).~n",[]),
   io:format("expected output:~n",[]),
   io:format("55~n",[]),
   io:format("usage example:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">preduce:start(fun(A,B) -> A+B  end, 0, L, 3).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above~n",[]),
   io:format("usage example:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">preduce:start(fun(A,B) -> A+B  end, 0, L, {processes,4}).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above~n",[])
).

-define(MAPRED_NAIVE_H,
   io:format("--- mapred_naive description ---~n",[]),
   io:format("takes two user-defined functions, the first one is a ",[]),
   io:format("mapper and the second is a reducer; an accumulator and ",[]),
   io:format("a list to be split into chunks. ~n",[]),
   io:format("you may also split the list by either choosing its ",[]),
   io:format("chunks' length or by using the parameter '{processes, X}'.~n",[]),
   io:format("where X is the number of processes. the list will be ",[]),
   io:format("split into X chunks of (mostly) the same length. ~n~n",[]),
   io:format("it starts as many processes as there are chunks in input, ",[]),
   io:format("computes intermediate results and sends those to the ",[]),
   io:format("reduce process. ~nthe final results are then collected ",[]),
   io:format("into a single output by adding them up. ~n~n",[]),
   io:format("usage example 1:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">M_Fun = fun(Chunk)-> lists:sum([X*X||X<-Chunk]) end.~n",[]),
   io:format(">R_Fun = fun(A,B) -> A+B end.~n",[]),
   io:format(">mapred_naive:start(M_Fun, R_Fun, L, 0).~n",[]),
   io:format("expected output:~n",[]),
   io:format("385~n"),

   io:format("usage example 2:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">M_Fun = fun(Chunk)-> [X*X||X<-Chunk] end.~n",[]),
   io:format(">R_Fun = fun(X,Y) -> X++Y end.~n",[]),
   io:format(">mapred_naive:start(M_Fun, R_Fun, L, [], ",[]),
   io:format("{processes, 4}).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[100,81,64,49,36,25,16,9,4,1]~n",[]),

   io:format("usage example 3:~n",[]),
   io:format(">L = [1,2,3,4,5,6,7,8,9,10].~n",[]),
   io:format(">M_Fun = fun(Chunk)-> [X*X||X<-Chunk] end.~n",[]),
   io:format(">R_Fun = fun(X,Y) -> X++Y end.~n",[]),
   io:format(">mapred_naive:start(M_Fun, R_Fun, L, [], 2).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above~n",[])
).

-define(MAPRED_SMART_H,
   io:format("TODO~n",[])
).

-define(MAPRED_GOOGLE_H,
   io:format("--- mapred_google description ---~n",[]),
   io:format("mapreduce implemented with erlang/otp's dict dictionary ",[]),
   io:format("data structure. ~n",[]),
   io:format("takes two user-defined map and reduce functions and a ",[]),
   io:format("list of inputs. it starts as many processes as there ",[]),
   io:format("elements in the input list, computes intermediate results ",[]),
   io:format("and sends those to the reduce processes. the final ",[]),
   io:format("results are then collected into a single output.~n ~n",[]),
   io:format("usage example:~n",[]),
   io:format(">IndexedFiles = utils:index_file_list(~c<dirpath>~c).~n",[$",$"]),
   io:format(">M_Fun = utils:match_to_file(<regex>).~n",[]),
   io:format(">R_Fun = fun utils:get_unique/3.~n",[]),
   io:format(">dict:find(<regex>, mapred_google:start(M_Fun,R_Fun,IndexedFiles)).~n",[]),
   io:format("expected output:~n",[]),
   io:format("{ok, [<filepath(s)-containing-regex>]}~n",[]),
   io:format("NB: <regex> is the erlang atom we are looking for, ",[]),
   io:format("~c<dirpath>~c is the string of the path of the directory ",[$",$"]),
   io:format("inside of which we are looking.~n")
).

-define(STREAM_H,
   io:format("--- stream farm description ---~n",[]),
   io:format("takes the number of worker processes (optional), ",[]),
   io:format("the task performed by each worker and a stream of chunks ",[]),
   io:format("of a list. ~n",[]),
   io:format("the emitter distributes each chunk between the workers ",[]),
   io:format("and the collector gathers the final output. ~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">List = [[12,3,45231],[1231,231,4],[1],[6,6,6,7,6]].~n",[]),
   io:format(">W_Fun = fun lists:sort/1.~n",[]),
   io:format(">stream:start_farm(4, W_Fun, List).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[[3,12,45231],[4,231,1231],[1],[6,6,6,6,7]]~n~n",[]),

   io:format("--- stream pipe description ---~n",[]),
   io:format("takes a list of stages(where each one represents a ",[]),
   io:format("function) and a list of chunks. ~n",[]),
   io:format("the output of one stage is the input of the next one.~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">List = [[12,3,45231],[1231,231,4],[1],[6,6,6,7,6]].~n",[]),
   io:format(">Stage_One = fun(Chunk) -> [X*X || X<-Chunk] end.~n",[]),
   io:format(">Stage_Two = fun lists:sort/1.~n",[]),
   io:format(">Stages = [Stage_One, Stage_Two].~n",[]),
   io:format(">stream:start_pipe(Stages, List).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[[9,144,2045843361],[16,53361,1515361],[1],[36,36,36,36,49]]~n~n",[]),

   io:format("--- stream pipe of farms description ---~n",[]),
   io:format("takes the number of worker processes (optional), ",[]),
   io:format("a list of stages(where each one represents a ",[]),
   io:format("function) and a list of chunks. ~n",[]),
   io:format("each stage is made up of a farm of workers.~n",[]),
   io:format("the output of one stage is the input of the next one.~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">List = [[12,3,45231],[1231,231,4],[1],[6,6,6,7,6]].~n",[]),
   io:format(">Stage_One = fun(Chunk) -> [X*X || X<-Chunk] end.~n",[]),
   io:format(">Stage_Two = fun lists:sum/1.~n",[]),
   io:format(">Stages = [Stage_One, Stage_Two].~n",[]),
   io:format(">stream:start_piped_farm(4, Stages, List).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[2045843514,1568738,1,193]~n",[])
).


-define(TEST_MR_H,
   io:format("--- test_mapred description ---~n",[]),
   io:format("testing, profiling and benchmarking for the mapreduce ",[]),
   io:format("data parallel skeletons. ~n",[]),
   io:format("the default configuration with no user input simply ",[]),
   io:format("computes the function f(X,EXP)=1+(sin(X))^(10*Exp), ",[]),
   io:format("where X is the element of a list of random numbers from 0 ",[]),
   io:format("to an upper bound (100 by default).~nthis is computed ",[]),
   io:format("over each element of an input list and the results are ",[]),
   io:format("added together to give a final result.~n",[]),
   io:format("EXP(20 by default) is the exponent to used for creating a ",[]),
   io:format("list of inputs(e.g. EXP=20 means that the list will be ",[]),
   io:format("made up of 2^20=1048576 random numbers).~n",[]),
   io:format("the number of schedulers is the same as the number of ",[]),
   io:format("those that are online and the list will be split into as ",[]),
   io:format("many chunks as there are schedulers online. ~n",[]),
   io:format("it is also possible for the user to specify the number of ",[]),
   io:format("schedulers to use, the value of EXP and the length of the ",[]),
   io:format("chunks into which the list will be split.~n~n",[]),
   io:format("usage example 1:~n",[]),
   io:format(">test_mapred:benchmark().~n",[]),
   io:format("expected output:~n",[]),
   io:format("a summary of the configuration used; the run-times, the ",[]),
   io:format("mean and median times over 12 iterations and the speedups.~n",[]),
   io:format("usage example 2:~n",[]),
   io:format(">test_mapred:benchmark(<schedulers-num>, <exp>, ",[]),
   io:format("<chunks-length>).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above.~n",[])
).

-define(TEST_MR_GOOGLE_H,
   io:format("--- test_mapred_google description ---~n",[]),
   io:format("testing, profiling and benchmarking for the mapreduce ",[]),
   io:format("data parallel skeletons (google version). ~n",[]),
   io:format("performs an unix-like grep operation by searching ",[]),
   io:format("an atom ('skepi' by default) inside a directory of files ",[]),
   io:format("containing lists of atoms (located in 'ske-pi/test' by ",[]),
   io:format("default). ~n",[]),
   io:format("the number of schedulers is the same as the number of ",[]),
   io:format("those that are online (by default). ~n",[]),
   io:format("it is also possible for the user to specify the number of ",[]),
   io:format("schedulers to use and either specify their own atom ",[]),
   io:format("or their own test directory or both.~n~n",[]),
   io:format("usage example 1:~n",[]),
   io:format(">test_mapred_google:benchmark().~n",[]),
   io:format("expected output:~n",[]),
   io:format("a summary of the configuration used and the number of ",[]),
   io:format("files to be read along with their names; the run-times, the ",[]),
   io:format("mean and median times over 12 iterations and the speedups.~n",[]),
   io:format("usage example 2:~n",[]),
   io:format(">test_mapred_google:benchmark(<schedulers-num>, ~c<test-", [$"]),
   io:format("directory>~c).~n",[$"]),
   io:format("expected output:~n",[]),
   io:format("same as above.~n",[]),
   io:format("usage example 3:~n",[]),
   io:format(">test_mapred_google:benchmark(<schedulers-num>, <atom>).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above.~n",[]),
   io:format("usage example 4:~n",[]),
   io:format(">test_mapred_google:benchmark(<schedulers-num>, <atom>, ",[]),
   io:format("~c<test-directory>~c).~n",[$",$"]),
   io:format("expected output:~n",[]),
   io:format("same as above.~n",[])
).

-define(TEST_STREAM_H,
   io:format("--- test_stream description ---~n",[]),
   io:format("testing, profiling and benchmarking for the stream ",[]),
   io:format("parallel skeletons. ~n",[]),
   io:format("the default configuration with no user input simply ",[]),
   io:format("computes the function f(X,EXP)=1+(sin(X))^(10*Exp), ",[]),
   io:format("where X is the element of a stream of random numbers from 0 ",[]),
   io:format("to an upper bound (100 by default).~nthis is computed ",[]),
   io:format("over each element of the stream and the results are ",[]),
   io:format("added together to give a final result.~n",[]),
   io:format("EXP(20 by default) is the exponent to used for creating a ",[]),
   io:format("list (e.g. EXP=20 means that the stream will be ",[]),
   io:format("made up of 2^20=1048576 random numbers) simulating a ",[]),
   io:format("stream of elements to be sent to the worker processes.~n",[]),
   io:format("by default, the number of schedulers is the same as the ",[]),
   io:format("number of those that are online.~nthe number of worker ",[]),
   io:format("processes is the same as the number of schedulers online ",[]),
   io:format("and the stream will be split into as many chunks ",[]),
   io:format("as there are schedulers online. ~n",[]),
   io:format("it is also possible for the user to specify the number of ",[]),
   io:format("workers to use, the number of schedulers, the value ",[]),
   io:format("of EXP and the length of the chunks into which ",[]),
   io:format("the input stream will be split.~n",[]),
   io:format("the computation will be performed by both a farm of ",[]),
   io:format("worker processes and two piped farms of worker ",[]),
   io:format("processes (i.e. a two stage pipe of farms, which is ",[]),
   io:format("a composition of both stream skeletons).~n~n",[]),
   io:format("usage example 1:~n",[]),
   io:format(">test_stream:benchmark().~n",[]),
   io:format("expected output:~n",[]),
   io:format("a summary of the configuration used; the run-times, the ",[]),
   io:format("mean and median times over 12 iterations and the speedups.~n",[]),
   io:format("usage example 2:~n",[]),
   io:format(">test_stream:benchmark(<workers-num>,<schedulers-num>,<exp>,",[]),
   io:format("<chunks-length>).~n",[]),
   io:format("expected output:~n",[]),
   io:format("same as above.~n",[])
).
