-define(PMAP_H,
   io:format("--- pmap description ---~n",[]),
   io:format("takes a function and a list of chunks. ~n",[]),
   io:format("it spawns a process for each element in the list ~n",[]),
   io:format("of chunks. each mapper process applies the function ~n",[]),
   io:format("to its chunk and collects the results (non-ordered)~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">List = [[12,3,45231],[1231,231,4],[1],[6,6,6,7,6]].~n",[]),
   io:format(">pmap:start(fun lists:sort/1, List).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[[6,6,6,6,7],[1],[4,231,1231],[3,12,45231]]~n",[])
).

-define(MAPRED_NAIVE_H,
   io:format("--- mapred_naive description ---~n",[]),
   io:format("takes an user-defined map function and a list of chunks. ~n",[]),
   io:format("it starts as many processes as there are chunks in input, ~n",[]),
   io:format("computes intermediate results and sends those to the  ~n",[]),
   io:format("reduce process. the final results are then collected ~n",[]),
   io:format("into a single output by adding them up.  ~n",[]),
   io:format("additionally, an user-defined reduce function (along~n",[]),
   io:format("with its accumulator) may be specified.~n~n",[]),
   io:format("usage example 1:~n",[]),
   io:format(">M_Fun = fun(Chunk)-> lists:sum([X*X||X<-Chunk]) end.~n",[]),
   io:format(">mapred_naive:start(M_Fun, [[1,2,3],[4,5]]).~n",[]),
   io:format("expected output:~n",[]),
   io:format("55~n~n"),

   io:format("usage example 2:~n",[]),
   io:format(">M_Fun = fun(Chunk)-> [X*X||X<-Chunk] end.~n",[]),
   io:format(">R_Fun = fun(X,Y) -> X++Y end.~n",[]),
   io:format(">mapred_naive:start(M_Fun, R_Fun, [[1,2,3],[4,5]], []).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[16,25,1,4,9]~n",[])
).

-define(MAPRED_GOOGLE_H,
   io:format("--- mapred_google description ---~n",[]),
   io:format("mapreduce implemented with erlang/otp's dict dictionary ~n",[]),
   io:format("data structure. ~n",[]),
   io:format("takes two user-defined map and reduce functions and a  ~n",[]),
   io:format("list of inputs. it starts as many processes as there~n",[]),
   io:format("elements in the input list, computes intermediate results~n",[]),
   io:format("and sends those to the reduce processes. the final  ~n",[]),
   io:format("results are then collected into a single output.~n ~n",[]),
   io:format("usage example:~n",[]),
   io:format(">IndexedFiles = utils:index_file_list(~c<dirpath>~c).~n",[$",$"]),
   io:format(">M_Fun = utils:match_to_file(<regex>).~n",[]),
   io:format(">R_Fun = fun utils:get_unique/3.~n",[]),
   io:format(">dict:find(<regex>, mapred_google:start(M_Fun,R_Fun,IndexedFiles)).~n",[]),
   io:format("expected output:~n",[]),
   io:format("{ok, [<filepath(s)-containing-regex>]}~n",[]),
   io:format("NB: <regex> is the erlang atom we are looking for,~n",[]),
   io:format("~c<dirpath>~c is the string of the path of the directory~n",[$",$"]),
   io:format("inside of which we are looking.~n")
).

-define(STREAM_H,
   io:format("--- stream farm description ---~n",[]),
   io:format("takes the number of worker processes (optional),~n",[]),
   io:format("the task performed by each worker and a stream of chunks~n",[]),
   io:format("of a list. ~n",[]),
   io:format("the emitter distributes each chunk between the workers ~n",[]),
   io:format("and the collector gathers the final output. ~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">List = [[12,3,45231],[1231,231,4],[1],[6,6,6,7,6]].~n",[]),
   io:format(">W_Fun = fun lists:sort/1.~n",[]),
   io:format(">stream:start_farm(4, W_Fun, List).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[[3,12,45231],[4,231,1231],[1],[6,6,6,6,7]]~n~n",[]),

   io:format("--- stream pipe description ---~n",[]),
   io:format("takes a list of stages(where each one represents a ~n",[]),
   io:format("function) and a list of chunks. ~n",[]),
   io:format("the output of one stage is the input of the next one.~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">List = [[12,3,45231],[1231,231,4],[1],[6,6,6,7,6]].~n",[]),
   io:format(">Stage_One = fun(Chunk) -> [X*X || X<-Chunk] end.~n",[]),
   io:format(">Stage_Two = fun lists:sort/1.~n",[]),
   io:format(">Stages = [Stage_One, Stage_Two].~n",[]),
   io:format(">stream:start_pipe(Stages, List).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[[9,144,2045843361],[16,53361,1515361],[1],[36,36,36,36,49]]~n~n",[]),

   io:format("--- stream pipe of farms description ---~n",[]),
   io:format("takes the number of worker processes (optional),~n",[]),
   io:format("a list of stages(where each one represents a ~n",[]),
   io:format("function) and a list of chunks. ~n",[]),
   io:format("each stage is made up of a farm of workers.~n",[]),
   io:format("the output of one stage is the input of the next one.~n~n",[]),
   io:format("usage example:~n",[]),
   io:format(">List = [[12,3,45231],[1231,231,4],[1],[6,6,6,7,6]].~n",[]),
   io:format(">Stage_One = fun(Chunk) -> [X*X || X<-Chunk] end.~n",[]),
   io:format(">Stage_Two = fun lists:sum/1.~n",[]),
   io:format(">Stages = [Stage_One, Stage_Two].~n",[]),
   io:format(">stream:start_piped_farm(4, Stages, List).~n",[]),
   io:format("expected output:~n",[]),
   io:format("[2045843514,1568738,1,193]~n",[])
).
